<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 | Koenigsegg的小屋</title><meta name="keywords" content="java"><meta name="author" content="张智为"><meta name="copyright" content="张智为"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础包装器比较大小12345678910public static void main(String[] args) &amp;#123;     Integer a &#x3D; new Integer(100);     Integer b &#x3D; new Integer(100);     &#x2F;* compareTo返回值：若a&gt;b则返回1；若a&#x3D;&#x3D;b则返回0；若a&lt;b则返回-1 *&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://zhangzhiwei0905.github.io/2022/04/14/java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Koenigsegg的小屋">
<meta property="og:description" content="Java基础包装器比较大小12345678910public static void main(String[] args) &amp;#123;     Integer a &#x3D; new Integer(100);     Integer b &#x3D; new Integer(100);     &#x2F;* compareTo返回值：若a&gt;b则返回1；若a&#x3D;&#x3D;b则返回0；若a&lt;b则返回-1 *&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/pexels-photo-3422964.jpeg">
<meta property="article:published_time" content="2022-04-14T09:07:14.000Z">
<meta property="article:modified_time" content="2022-04-15T06:53:40.296Z">
<meta property="article:author" content="张智为">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/pexels-photo-3422964.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhangzhiwei0905.github.io/2022/04/14/java%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-15 14:53:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/duotone.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/WechatIMG26.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/pexels-photo-3422964.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Koenigsegg的小屋</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-14T09:07:14.000Z" title="Created 2022-04-14 17:07:14">2022-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-15T06:53:40.296Z" title="Updated 2022-04-15 14:53:40">2022-04-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="包装器比较大小"><a href="#包装器比较大小" class="headerlink" title="包装器比较大小"></a>包装器比较大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">100</span>);<br>     <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">100</span>);<br>     <span class="hljs-comment">/* compareTo返回值：若a&gt;b则返回1；若a==b则返回0；若a&lt;b则返回-1 */</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a.compareTo(b);<br>     System.out.println(a &gt; b);<br>     System.out.println(a == b);<br>     System.out.println(a &gt; b);<br>     System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">false<br>false<br>false<br>0<br></code></pre></td></tr></table></figure>

<p>解释：</p>
<p>”&#x3D;&#x3D;“判断，如果是<u>基本类型</u>就直接判断<strong>其值是否相等</strong>，如果是<u>对象</u>就判断是否是<strong>同一个对象的引用</strong>。</p>
<p>“Equals”判断，默认情况下，比较内存地址值是否相等。如果equals方法被重写（例如，String），比较的是地址里的内容。</p>
<h2 id="hashCode与equals-比较"><a href="#hashCode与equals-比较" class="headerlink" title="hashCode与equals()比较"></a>hashCode与equals()比较</h2><blockquote>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>&#x3D;&#x3D;如果对象相等，对两个equals方法返回true&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;两个对象有相同的hashcode值，它们也不一定是相等的&#x3D;&#x3D;</li>
<li>综上，equals方法被覆盖过，则hashcode方法也必须被覆盖</li>
<li>hashcode的默认行为是对堆上的对象产生独特值。如果没有重写hashcode，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
<li>Equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是&#x3D;&#x3D;绝对可靠&#x3D;&#x3D;的。</li>
<li>hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()&#x3D;&#x3D;不是绝对可靠&#x3D;&#x3D;的。</li>
</ol>
</blockquote>
<h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><table>
<thead>
<tr>
<th align="center"><span style='color:red;background:背景颜色;font-size:文字大小;'>不同点</span></th>
<th align="center">能否为普通方法提供方法体</th>
<th align="center">Public static final 赋值</th>
<th align="center">是否有构造器</th>
<th>能否包含初始化块</th>
<th>继承问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">抽象类</td>
<td align="center">可以包含普通方法</td>
<td align="center">成员变量可以为任意类型</td>
<td align="center">可以包含构造器，但不是用来创建对象的，而是让子类调用这些构造器来完成属于抽象类的<span style='color:red;background:背景颜色;font-size:文字大小;'>初始化操作</span></td>
<td>可以包含</td>
<td>一个类只能继承一个抽象类</td>
</tr>
<tr>
<td align="center">接口</td>
<td align="center">只能包含抽象方法（默认），静态方法和默认方法（加default）</td>
<td align="center"><span style='color:red;background:背景颜色;font-size:文字大小;'>只能是public static final并且必须赋值，否则不能编译</span></td>
<td align="center">不能包含构造器</td>
<td>不能包含</td>
<td>一个类可以实现多个接口</td>
</tr>
</tbody></table>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>相同点：</span></p>
<ul>
<li>接口和抽象类都不能被实例化，都位于继承树的顶端，用于被其他类实现和继承</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法</li>
</ul>
<blockquote>
<p>接口中可以包含变量和方法，变量被隐式指定为 public static final，方法被隐式指定为 public abstract（JDK 1.8 之前）</p>
</blockquote>
<h2 id="重写、重载、重构"><a href="#重写、重载、重构" class="headerlink" title="重写、重载、重构"></a>重写、重载、重构</h2><p><span style='color:blue;background:背景颜色;font-size:文字大小;'>重载实现编译时的多态性，重写实现运行时的多态性！</span></p>
<h3 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）:"></a>重载（overload）:</h3><p>重载就是在同一个类中允许同时存在一个以上的同名方法,<span style='color:red;background:背景颜色;font-size:文字大小;'>只要这些方法的参数个数或类型不同即可</span>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverLoadTest</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 定义不定长参数方法</span><br><span class="hljs-comment">	 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>... a)</span><br>  &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++)<br>    &#123;<br>      s += a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;调用add(int,int)方法：&quot;</span> + add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    System.out.println(<span class="hljs-string">&quot;调用add(int,int,int)方法：&quot;</span> + add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br>    System.out.println(<span class="hljs-string">&quot;调用add(double,double)方法：&quot;</span> + add(<span class="hljs-number">2.1</span>, <span class="hljs-number">3.5</span>));<br>    <span class="hljs-comment">// 调用不定长参数方法</span><br>    System.out.println(<span class="hljs-string">&quot;调用不定长参数方法：&quot;</span> + add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>));<br>    System.out.println(<span class="hljs-string">&quot;调用不定长参数方法：&quot;</span> + add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong>虽然在方法重载中可以使用两个方法的返回类型不同，但只有返回类型不同并不足以区分两个方法的重载，还需要通过参数的个数以及参数的类型来设置。</p>
<p><strong>重载的规则：</strong></p>
<p>（1）必须具有不同的参数列表。</p>
<p>（2）可以有不同的返回类型，只要参数列表不同就可以了。</p>
<p>（3）可以有不同的访问修饰符。</p>
<p>（4）可以抛出不同的异常。</p>
<h3 id="重写（override）"><a href="#重写（override）" class="headerlink" title="重写（override）:"></a>重写（override）:</h3><p>重写（还可以称为覆盖）就是在子类中将父类的成员方法的名称保留，重写成员方法的实现内容，更改成员方法的存储权限，或是修改成员方法的返回值类型</p>
<p>Parent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 构造方法</span><br><span class="hljs-comment">	 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Parent</span><span class="hljs-params">()</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;父类构造方法！&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 成员方法</span><br><span class="hljs-comment">	 */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;父类方法&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 成员方法,返回类型为Parent类型</span><br><span class="hljs-comment">	 */</span><br>  <span class="hljs-keyword">protected</span> Parent <span class="hljs-title function_">doIt</span><span class="hljs-params">()</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Children.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> <span class="hljs-comment">// 继承父类</span><br>&#123;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 构造方法</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Children</span><span class="hljs-params">()</span><br>	&#123;<br>		<span class="hljs-comment">// 调用父类构成方法</span><br>		<span class="hljs-built_in">super</span>();<br> <br>		<span class="hljs-comment">// 调用父类成员方法</span><br>		<span class="hljs-built_in">super</span>.doSomething();<br> <br>		<span class="hljs-comment">// 子类构造方法</span><br>		System.out.println(<span class="hljs-string">&quot;子类构造方法&quot;</span>);<br>	&#125;<br> <br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 子类新增方法</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingNew</span><span class="hljs-params">()</span><br>	&#123;<br>		System.out.println(<span class="hljs-string">&quot;子类新增方法&quot;</span>);<br>	&#125;<br> <br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 重写父类方法</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span><br>	&#123;<br>		System.out.println(<span class="hljs-string">&quot;子类重写父类方法&quot;</span>);<br>	&#125;<br> <br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 重写父类方法，返回类型为Children类型</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">protected</span> Children <span class="hljs-title function_">doIt</span><span class="hljs-params">()</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Children</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>子类重写父类的方法还可以修改方法的返回值类型，但这只是在J2SE 5.0以上的版本中支持的新功能。示例中子类中的doIt()方法就使用了这个新功能，父类中的doIt()方法的返回值类型为Parent类，而子类中的doIt()方法的返回值类型为Children类，子类中重写了父类的doIt()方法。<span style='color:red;background:背景颜色;fontr-size:文字大小;'>这种重写方式需要遵循一个原则，即重写的返回值类型必须是父类中同一方法返回值类型的子类</span>，而Children类正是Parent类的子类。<br><strong>注意：</strong>当重写父类方法时，<span style='color:red;background:背景颜色;font-size:文字大小;'>修改方法的修饰权限只能从小的范围到大的范围改变</span>，例如，父类中的dosomething()方法的修饰权限为protected，继承后子类中的方法doSomething()的修饰权限只能修改为public，不能修改为private。</p>
<p>重写的规则：</p>
<p>（1）参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p>（2）访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）。</p>
<p>（3）重写方法<span style='color:red;background:背景颜色;font-size:文字大小;'>一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</span>。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception，只能抛出IOException的子类异常，可以抛出非检查异常。</p>
<h3 id="重构："><a href="#重构：" class="headerlink" title="重构："></a>重构：</h3><p>是重写的一种特殊方式，子类与父类的成员方法的返回值、方法名称、参数类型及个数完全相同，唯一不同的是方法实现内容，这种特殊重写方式被称为重构。</p>
<h2 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object clone()"></a>Object clone()</h2><p>Object clone() 方法用于创建并返回一个对象的拷贝。</p>
<p>clone 方法是浅拷贝，对象内属性引用的对象只会拷贝引用地址，而不会将引用的对象重新分配内存，相对应的深拷贝则会连引用的对象也重新创建。</p>
<p><strong>由于 Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生 CloneNotSupportedException 异常。</strong></p>
<h2 id="String类-equals"><a href="#String类-equals" class="headerlink" title="String类 equals()"></a>String类 equals()</h2><p>String 类重写了 equals() 方法，用于比较两个字符串是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">// String 类使用 equals() 方法</span><br>    <span class="hljs-comment">// 创建两个对象</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><br>    <span class="hljs-comment">// 判断 obj1 与 obj2 是否相等</span><br>    <span class="hljs-comment">// 初始化的两个对象都为 null，所以是相等，返回 true</span><br>    System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// true</span><br><br>    <span class="hljs-comment">// 给对象赋值</span><br>    obj1 = <span class="hljs-string">&quot;Runoob&quot;</span>;<br>    obj2 = <span class="hljs-string">&quot;Google&quot;</span>;<br><br>    <span class="hljs-comment">// 判断 obj1 与 obj2 是否相等</span><br>    <span class="hljs-comment">// 两个值不同，内存地址也不同，所以不相等，返回 false</span><br>    System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// false</span><br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><blockquote>
<p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
</blockquote>
<p>类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。</p>
<p>ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> IOException<br></code></pre></td></tr></table></figure>

<p>上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException<br></code></pre></td></tr></table></figure>

<p>该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>Employee.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br>&#123;<br>  <span class="hljs-keyword">public</span> String name;<br>  <span class="hljs-keyword">public</span> String address;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> SSN;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> number;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mailCheck</span><span class="hljs-params">()</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;Mailing a check to &quot;</span> + name<br>                       + <span class="hljs-string">&quot; &quot;</span> + address);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>请注意，一个类的对象要想序列化成功，必须满足两个条件：</p>
<ul>
<li><p>该类必须实现 java.io.Serializable 接口。</p>
</li>
<li><p>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂（transient）的。</p>
</li>
</ul>
<h3 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h3><p>ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。</p>
<p>该程序执行后，就创建了一个名为 employee.ser 文件。该程序没有任何输出，但是你可以通过代码研读来理解程序的作用。</p>
<p><strong>注意：</strong> 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名。</p>
<p><strong>SerializeDemo.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializeDemo</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span><br>  &#123;<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>    e.name = <span class="hljs-string">&quot;Reyan Ali&quot;</span>;<br>    e.address = <span class="hljs-string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>;<br>    e.SSN = <span class="hljs-number">11122333</span>;<br>    e.number = <span class="hljs-number">101</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOut</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/tmp/employee.ser&quot;</span>);<br>      <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOut);<br>      out.writeObject(e);<br>      out.close();<br>      fileOut.close();<br>      System.out.printf(<span class="hljs-string">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(IOException i)<br>    &#123;<br>      i.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="反序列化对象"><a href="#反序列化对象" class="headerlink" title="反序列化对象"></a>反序列化对象</h3><p>下面的 DeserializeDemo 程序实例了反序列化，&#x2F;tmp&#x2F;employee.ser 存储了 Employee 对象。</p>
<p><strong>DeserializeDemo.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeserializeDemo</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span><br>  &#123;<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>      <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/tmp/employee.ser&quot;</span>);<br>      <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileIn);<br>      e = (Employee) in.readObject();<br>      in.close();<br>      fileIn.close();<br>    &#125;<span class="hljs-keyword">catch</span>(IOException i)<br>    &#123;<br>      i.printStackTrace();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException c)<br>    &#123;<br>      System.out.println(<span class="hljs-string">&quot;Employee class not found&quot;</span>);<br>      c.printStackTrace();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Deserialized Employee...&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;Name: &quot;</span> + e.name);<br>    System.out.println(<span class="hljs-string">&quot;Address: &quot;</span> + e.address);<br>    System.out.println(<span class="hljs-string">&quot;SSN: &quot;</span> + e.SSN);<br>    System.out.println(<span class="hljs-string">&quot;Number: &quot;</span> + e.number);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注：</strong>readObject() 方法的返回值被转化成 Employee 引用。</p>
<p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p>
<h2 id="基本类型对应的包装类表"><a href="#基本类型对应的包装类表" class="headerlink" title="基本类型对应的包装类表"></a>基本类型对应的包装类表</h2><table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">引用类型</th>
<th align="center">默认值</th>
<th align="center">取值范围</th>
<th align="center">存储需求</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
<td align="center">false</td>
<td align="center">true\false</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">Byte</td>
<td align="center">0</td>
<td align="center">$(-2^7,2^7-1)$</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
<td align="center">‘\u0000’</td>
<td align="center">$(0,2^{16}-1)$</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
<td align="center">0</td>
<td align="center">$(-2^{15},2^{15}-1)$</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
<td align="center">0</td>
<td align="center">$(-2^{31},2^{31}-1)$</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
<td align="center">0</td>
<td align="center">$(-2^{63},2^{63}-1)$</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
<td align="center">0.0f</td>
<td align="center">$(-2^{31},2^{31}-1)$</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
<td align="center">0.0d</td>
<td align="center">$(-2^{63},2^{63}-1)$</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，使用StringBuffer类。</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>String不可变的几点原因:</span></p>
<blockquote>
<ol>
<li>如果字符串可变会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得的</li>
<li>因为字符串不可变，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步了，自己就是线程安全的</li>
<li>字符串不可变，所以在创建的时候hashCode就被缓存了，不变性保证了hash码的唯一性，不需要重新计算，这就使得字符串很适合作为Map的键，处理速度快过其它的键对象。</li>
<li>因为被声明了final类，且类内部的value字节数组也是final的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串</li>
</ol>
</blockquote>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>基本类型和包装类型的区别：</span></p>
<blockquote>
<ol>
<li>在Java中，一切皆对象，但八大基本类型却不是对象。</li>
<li>声明方式的不同，基本类型无需通过new关键字来创建，而封装类型需new关键字。</li>
<li>存储方式及位置的不同，基本类型是直接存储变量的值保存在堆栈中能高效的存取，封装类型需要通过引用指向实例，具体的实例保存在堆中。</li>
<li>初始值的不同，封装类型的初始值为null，基本类型的的初始值视具体的类型而定，比如int类型的初始值为0，boolean类型为false；</li>
<li>使用方式的不同，比如与集合类合作使用时只能使用包装类型。</li>
<li>什么时候该用包装类，什么时候用基本类型，看基本的业务来定：&#x3D;&#x3D;这个字段允不允许null值，如果允许null值，则必然要用封装类&#x3D;&#x3D;，否则值类型就可以了，用到比如泛型和反射调用函数.，就需要用包装类！</li>
</ol>
</blockquote>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ol>
<li><p>用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享；</p>
</li>
<li><p>用来修饰成员方法，将其变为类方法，可以直接使用<strong>“类名.方法名”</strong>的方式调用，常用于工具类；</p>
</li>
<li><p>静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键；</p>
<p>注：当我们第一次去使用一个类时，就会触发该类的成员初始化。第二个是当我们使用了类方法，完成类的成员的初始化后，再new该类的对象时，static修饰的类成员没有再次初始化，这说明，static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。</p>
</li>
<li><p>静态导包用法，将类的方法直接导入到当前类中，从而直接使用<strong>“方法名”</strong>即可调用类方法，更加方便。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>  <span class="hljs-type">Book</span> <span class="hljs-variable">book1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book1成员变量初始化&quot;</span>);<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">Book</span> <span class="hljs-variable">book2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;static成员book2成员变量初始化&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(msg);<br>  &#125;<br><br>  <span class="hljs-type">Book</span> <span class="hljs-variable">book3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;book3成员变量初始化&quot;</span>);<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">Book</span> <span class="hljs-variable">book4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;static成员book4成员变量初始化&quot;</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">funStatic</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;static修饰的funStatic方法&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Person.funStatic();<br>    System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;p1初始化&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">/**Output</span><br><span class="hljs-comment">     * static成员book2成员变量初始化</span><br><span class="hljs-comment">     * static成员book4成员变量初始化</span><br><span class="hljs-comment">     * static修饰的funStatic方法</span><br><span class="hljs-comment">     * ***************</span><br><span class="hljs-comment">     * book1成员变量初始化</span><br><span class="hljs-comment">     * book3成员变量初始化</span><br><span class="hljs-comment">     * p1初始化</span><br><span class="hljs-comment">     */</span><span class="hljs-comment">//~</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a>Java String</h2><h3 id="由基本数据形态转化为String"><a href="#由基本数据形态转化为String" class="headerlink" title="由基本数据形态转化为String"></a>由基本数据形态转化为String</h3><p>String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 ，也就是 String.valueOf() 这个参数多载的方法</p>
<p>有以下几种</p>
<p>（1）String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串</p>
<p>（2）String.valueOf(char c) : 将 char 变量 c 转换成字符串</p>
<p>（3）String.valueOf(char[] data) : 将 char 数组 data 转换成字符串</p>
<p>（4）String.valueOf(char[] data, int offset, int count) : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串</p>
<p>（5）String.valueOf(double d) : 将 double 变量 d 转换成字符串</p>
<p>（6）String.valueOf(float f) : 将 float 变量 f 转换成字符串</p>
<p>（7）String.valueOf(int i) : 将 int 变量 i 转换成字符串</p>
<p>（8）String.valueOf(long l) : 将 long 变量 l 转换成字符串</p>
<p>（9）String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString()</p>
<h3 id="由String转化为数字的基本数据形态"><a href="#由String转化为数字的基本数据形态" class="headerlink" title="由String转化为数字的基本数据形态"></a>由String转化为数字的基本数据形态</h3><p>要将 String 转换成基本数据型态转 ，大多需要使用基本数据型态的包装类别</p>
<p>比如说 String 转换成 byte ，可以使用 Byte.parseByte(String s) ，这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException</p>
<p>（1）byte : Byte.parseByte(String s) : 将 s 转换成 byte</p>
<p>（2）Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte ，比如说 Byte.parseByte(“11”, 16) 会得到 17</p>
<p>（3）double : Double.parseDouble(String s) : 将 s 转换成 double</p>
<p>（4）float : Double.parseFloat(String s) : 将 s 转换成 float</p>
<p>（5）int : Integer.parseInt(String s) : 将 s 转换成 int</p>
<p>（6）long : Long.parseLong(String s)</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>补充知识</span>：Java常用之String.valueOf、toString、(String)</p>
<p>字符串类型的转型在java中常用的方法有标题中的三种。</p>
<p><strong>简单介绍：</strong></p>
<p>1、toString，需要保证调用这个方法的类、方法、变量不为null，否则会报空指针。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>System.out.println(x.toString());  <br>System.out.println(Integer.toString(<span class="hljs-number">12</span>)); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>toString():</strong> 返回表示 Integer 值的 String 对象。</li>
<li><strong>toString(int i):</strong> 返回表示指定 int 的 String 对象。</li>
</ul>
</blockquote>
<p>2、String.valueOf。这个方法在使用的时候是有些特殊的。一般情况下，如果是确定类型的null传入，返回的是字符串“null”，而如果直接传入null，则会发生错误。</p>
<p>3、(String) 字符串类型强转。需要保证的是类型可以转成String类型。</p>
<p>这里重点介绍valueOf。</p>
<blockquote>
<p>String teString&#x3D;null;<br>teString&#x3D;String.valueOf(teString);<br>System.out.println(teString);</p>
</blockquote>
<h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h2><ul>
<li><p>当&#x3D;&#x3D;对字符串进行修改&#x3D;&#x3D;的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
</li>
<li><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
</li>
<li><p>在使用 &#x3D;&#x3D;StringBuffer&#x3D;&#x3D;类时，每次都会对 StringBuffer 对象本身进行操作，而&#x3D;&#x3D;不是生成新的对象&#x3D;&#x3D;，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p>
</li>
<li><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 &#x3D;&#x3D;StringBuilder 的方法不是线程安全的&#x3D;&#x3D;（不能同步访问）,线程安全要使用<span style='color:red;background:背景颜色;font-size:文字大小;'>StringBuffer</span>.</p>
</li>
<li><p>由于 StringBuilder 相较于 StringBuffer &#x3D;&#x3D;有速度优势&#x3D;&#x3D;，所以多数情况下建议使用 &#x3D;&#x3D;StringBuilder 类&#x3D;&#x3D;。</p>
</li>
</ul>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">10</span>);<br>    sb.append(<span class="hljs-string">&quot;Runoob..&quot;</span>);<br>    System.out.println(sb);  <br>    sb.append(<span class="hljs-string">&quot;!&quot;</span>);<br>    System.out.println(sb); <br>    sb.insert(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>    System.out.println(sb); <br>    sb.delete(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);<br>    System.out.println(sb);  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Runoob..<br>Runoob..!<br>Runoob..Java!<br>RunooJava!<br></code></pre></td></tr></table></figure>



<h2 id="向上转型和向下转型"><a href="#向上转型和向下转型" class="headerlink" title="向上转型和向下转型"></a>向上转型和向下转型</h2><blockquote>
<p><strong>1. <span style='color:red;background:背景颜色;font-size:文字大小;'>父类引用指向子类对象(向上转型)，而子类引用不能指向父类对象</span>。</strong></p>
<p><strong>2. &#x3D;&#x3D;把子类对象直接赋给父类引用叫upcasting向上转型&#x3D;&#x3D;，向上转型&#x3D;&#x3D;不用强制转换&#x3D;&#x3D;。</strong></p>
<p><strong>如：Father f1 &#x3D; new Son();</strong></p>
<p><strong>3. &#x3D;&#x3D;把指向子类对象的父类引用赋给子类引用叫向下转型&#x3D;&#x3D;(downcasting)，&#x3D;&#x3D;要强制转换&#x3D;&#x3D;。</strong></p>
<p><strong>如：f1 就是一个指向子类对象的父类引用。把f1赋给子类引用s1即 Son s1 &#x3D; (Son)f1；</strong></p>
<p><strong>其中f1前面的(Son)必须加上，进行强制转换。</strong></p>
</blockquote>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>为什么要进行向上转型、向下转型：</span></p>
<p>向上转型：</p>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>向上转型后，父类引用可以调用子类重写父类的方法</span></p>
<blockquote>
<p>举例：当要测试各个子类的eat方法时，只需要写一个testEat方法即可，通过向上转型机制，决定去调用哪个子类的eat方法</p>
<p><img src="/./img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWNzZ29hdA==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
</blockquote>
<p>向下转型：</p>
<blockquote>
<p>向下转型一般是为了重新获得因为向上转型而丢失的子类特性而存在；因此，<span style='color:red;background:背景颜色;font-size:文字大小;'>通常在向下转型前常有向上转型</span>，而向下转型通常也会结合instanceof一起使用。</p>
<p>借由向下转型，可以在灵活应用多态的基础上，同时兼顾子类的独有特征。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Cat：猫&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Cat：可爱的小猫&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">staticName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Dog：我是喵星人&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cat：吃饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticEat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cat：猫在吃饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cat：猫喜欢吃鱼&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(); <span class="hljs-comment">// 向上转型</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal; <span class="hljs-comment">// 向下转型</span><br>        System.out.println(animal.name); <span class="hljs-comment">// 输出Animal类的name变量</span><br>        System.out.println(animal.staticName); <span class="hljs-comment">// 输出Animal类的staticName变量</span><br>        animal.eat(); <span class="hljs-comment">// 输出Cat类的eat()方法</span><br>        animal.staticEat(); <span class="hljs-comment">// 输出Animal类的staticEat()方法</span><br>        System.out.println(cat.str); <span class="hljs-comment">// 调用Cat类的str变量</span><br>        cat.eatMethod(); <span class="hljs-comment">// 调用Cat类的eatMethod()方法</span><br>      	animal.eatMethod(); <span class="hljs-comment">// 输出和上面一样，也是cat的eatMethod方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过引用类型变量来访问所引用对象的属性和方法时，Java 虚拟机将采用以下绑定规则：</p>
<ul>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'>实例方法与引用变量实际引用的对象的方法进行绑定，这种绑定属于动态绑定</span>，因为是在运行时由 Java 虚拟机动态决定的。例如，animal.eat() 是将 eat() 方法与 Cat 类绑定。</li>
<li>静态方法与引用变量所声明的类型的方法绑定，这种绑定属于静态绑定，因为是在编译阶段已经做了绑定。例如，animal.staticEat() 是将 staticEat() 方法与 Animal 类进行绑定。</li>
<li>成员变量（包括静态变量和实例变量）与引用变量所声明的类型的成员变量绑定，这种绑定属于静态绑定，因为在编译阶段已经做了绑定。例如，animal.name 和 animal.staticName 都是与 Animal 类进行绑定。</li>
</ul>
<p>类型强制转换时想运行成功就必须保证父类引用指向的对象一定是该子类对象，最好使用 instanceof 运算符判断后，再强转，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();   <span class="hljs-comment">// 父类引用指向子类对象</span><br><span class="hljs-keyword">if</span> (animal <span class="hljs-keyword">instanceof</span> Cat) &#123;<br>    <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> (Cat) animal; <span class="hljs-comment">// 向下转型</span><br>    ...<br>&#125;<br><br><span class="hljs-comment">// 所以一般先进行向上转型，然后进行向下转型</span><br></code></pre></td></tr></table></figure>



<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p><strong>作用：</strong></p>
<ol>
<li>内部类可以很好的实现隐藏 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以 </li>
<li><span style='color:red;background:背景颜色;font-size:文字大小;'>内部类拥有外围类的所有元素的访问权限 (private修饰也能访问) </span></li>
<li>可是实现多重继承 (让多个内部类分别继承多个其他类，使外部类可以同时获取多个其他类的属性) </li>
<li>可以避免修改接口而实现同一个类中两种同名方法的调用。(外部类继承，让内部类实现接口)</li>
</ol>
<p><strong>分类</strong>：</p>
<ul>
<li>静态内部类</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticInerCls</span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态内部类除了访问权限修饰符比外围类多以外, 和外围类没有区别, 只是代码上将静态内部类组织在了外部类里面。</p>
<p>创建静态内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">OuterClass.<span class="hljs-type">StaticInerCls</span> <span class="hljs-variable">staticInerCls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>.StaticInerCls(); <br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>非静态内部类</li>
</ul>
<blockquote>
<p>非静态内部类能访问外部类的一切成员, 包括私有成员。外部类虽然不能直接访问内部类的成员, 但是可以通过内部类的实例访问内部类的私有成员。</p>
<p>分类：</p>
<ul>
<li><p>成员内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterCls</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">InerCls</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建内部类对象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OuterCls</span> <span class="hljs-variable">outerCls</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterCls</span>();<br>OuterCls.<span class="hljs-type">InerCls</span> <span class="hljs-variable">inerCls</span> <span class="hljs-operator">=</span> outerCls.<span class="hljs-keyword">new</span> <span class="hljs-title class_">InerCls</span>();  <br></code></pre></td></tr></table></figure>

<p>成员内部类不能有static修饰的成员，但是却允许定义常量。</p>
</li>
<li><p>局部内部类</p>
<p>指内部类定义在方法体内，只能在该方法或条件的作用域内才能使用，退出这写作用域就无法引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterCls</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getInerCls</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">InerCls</span>&#123;<br>      <span class="hljs-keyword">private</span> String name;<br>      <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>匿名内部类</p>
<p>为了免去给内部类命名，或者只想使用一次，就可以选择使用匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>  &#125;.start();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>内部类和静态内部类的区别：</span></p>
<p><img src="/./img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/hhhh.png" alt="Screen Shot 2021-04-07 at 5.14.04 PM"></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>1.final修饰变量，则等同于常量</p>
<p>2.final修饰方法中的参数，称为最终参数。</p>
<p>3.final修饰类，则类不能被继承</p>
<p>4.final修饰方法，则方法不能被重写。</p>
<p>5.final 不能修饰抽象类</p>
<p>6.final修饰的方法可以被重载 但不能被重写</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><span style='color:red;background:背景颜色;font-size:文字大小;'>按操作方式分类结构图：</span></p>
<p><img src="/./img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/format,png.jpeg" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="/./img/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/format,png-20211004134317706.jpeg" alt="IO-操作对象分类"></p>
<h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ul>
<li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li>
<li>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li>
</ul>
<h3 id="JAVA常用的节点流："><a href="#JAVA常用的节点流：" class="headerlink" title="JAVA常用的节点流："></a><strong>JAVA常用的节点流：</strong></h3><ul>
<li>文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。</li>
<li>字符串 StringReader StringWriter 对字符串进行处理的节点流。</li>
<li>数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li>
<li>管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。</li>
</ul>
<h3 id="常用处理流（关闭处理流使用关闭里面的节点流）"><a href="#常用处理流（关闭处理流使用关闭里面的节点流）" class="headerlink" title="常用处理流（关闭处理流使用关闭里面的节点流）"></a><strong>常用处理流（关闭处理流使用关闭里面的节点流）</strong></h3><ul>
<li><p>缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。</p>
</li>
<li><p>转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。</p>
</li>
<li><p>数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.</p>
</li>
</ul>
<h3 id="流的关闭顺序"><a href="#流的关闭顺序" class="headerlink" title="流的关闭顺序"></a>流的关闭顺序</h3><ol>
<li>一般情况下是：先打开的后关闭，后打开的先关闭</li>
<li>另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b</li>
<li>可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。</li>
</ol>
<h3 id="字符流和字节流怎么选"><a href="#字符流和字节流怎么选" class="headerlink" title="字符流和字节流怎么选"></a>字符流和字节流怎么选</h3><ol>
<li>绝大多数情况下使用字节流更好，因为字节流是字符流的包装，而大多数时候IO操作都是直接操作磁盘文件，所以这些流在传输时都是以字节的方式进行的（包括图片）。</li>
<li>如果对于操作需要通过IO在内存中频繁处理字符串的情况使用字符流会好些，因为字符流具备缓冲区，提高了性能。</li>
</ol>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</p>
<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；</p>
<p>如果整型字面量的值在-128到127之间，那么&#x3D;&#x3D;自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象&#x3D;&#x3D;，超过范围 a1&#x3D;&#x3D;b1的结果是false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;  <span class="hljs-comment">// 将3自动装箱成Integer类型</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    System.out.println(a == b); <span class="hljs-comment">// false 两个引用没有引用同一对象</span><br>    System.out.println(a == c); <span class="hljs-comment">// true a自动拆箱成int类型再和c比较</span><br>    System.out.println(b == c); <span class="hljs-comment">// true</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    System.out.println(a1 == b1); <span class="hljs-comment">// false</span><br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    System.out.println(a2 == b2); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">张智为</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://zhangzhiwei0905.github.io/2022/04/14/java%E5%9F%BA%E7%A1%80/">https://zhangzhiwei0905.github.io/2022/04/14/java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/pexels-photo-3422964.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/04/15/java%E9%9B%86%E5%90%88/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/1139924.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Java集合</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/04/15/java%E9%9B%86%E5%90%88/" title="Java集合"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/1139924.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-15</div><div class="title">Java集合</div></div></a></div><div><a href="/2022/04/16/java%E9%AB%98%E7%BA%A7/" title="Java高级"><img class="cover" src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/porsche-911-gt2-ga121c3ab8_1920.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-16</div><div class="title">Java高级</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/WechatIMG26.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">张智为</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zhangzhiwei0905"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zhangzhiwei0905" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%99%A8%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.</span> <span class="toc-text">包装器比较大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode%E4%B8%8Eequals-%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.</span> <span class="toc-text">hashCode与equals()比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">抽象类和接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">重写、重载、重构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">重载（overload）:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">重写（override）:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">重构：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-clone"><span class="toc-number">1.5.</span> <span class="toc-text">Object clone()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB-equals"><span class="toc-number">1.6.</span> <span class="toc-text">String类 equals()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">序列化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.3.</span> <span class="toc-text">反序列化对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E8%A1%A8"><span class="toc-number">1.8.</span> <span class="toc-text">基本类型对应的包装类表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-String"><span class="toc-number">1.10.</span> <span class="toc-text">Java String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%BD%A2%E6%80%81%E8%BD%AC%E5%8C%96%E4%B8%BAString"><span class="toc-number">1.10.1.</span> <span class="toc-text">由基本数据形态转化为String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1String%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%BD%A2%E6%80%81"><span class="toc-number">1.10.2.</span> <span class="toc-text">由String转化为数字的基本数据形态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="toc-number">1.11.</span> <span class="toc-text">StringBuffer和StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.12.</span> <span class="toc-text">向上转型和向下转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.13.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.14.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">1.15.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.15.1.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%B8%B8%E7%94%A8%E7%9A%84%E8%8A%82%E7%82%B9%E6%B5%81%EF%BC%9A"><span class="toc-number">1.15.2.</span> <span class="toc-text">JAVA常用的节点流：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86%E6%B5%81%EF%BC%88%E5%85%B3%E9%97%AD%E5%A4%84%E7%90%86%E6%B5%81%E4%BD%BF%E7%94%A8%E5%85%B3%E9%97%AD%E9%87%8C%E9%9D%A2%E7%9A%84%E8%8A%82%E7%82%B9%E6%B5%81%EF%BC%89"><span class="toc-number">1.15.3.</span> <span class="toc-text">常用处理流（关闭处理流使用关闭里面的节点流）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E5%85%B3%E9%97%AD%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.15.4.</span> <span class="toc-text">流的关闭顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E6%80%8E%E4%B9%88%E9%80%89"><span class="toc-number">1.15.5.</span> <span class="toc-text">字符流和字节流怎么选</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">1.16.</span> <span class="toc-text">自动装箱和拆箱</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/java%E9%AB%98%E7%BA%A7/" title="Java高级"><img src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/porsche-911-gt2-ga121c3ab8_1920.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java高级"/></a><div class="content"><a class="title" href="/2022/04/16/java%E9%AB%98%E7%BA%A7/" title="Java高级">Java高级</a><time datetime="2022-04-16T04:14:59.000Z" title="Created 2022-04-16 12:14:59">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/15/java%E9%9B%86%E5%90%88/" title="Java集合"><img src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/1139924.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合"/></a><div class="content"><a class="title" href="/2022/04/15/java%E9%9B%86%E5%90%88/" title="Java集合">Java集合</a><time datetime="2022-04-15T03:48:42.000Z" title="Created 2022-04-15 11:48:42">2022-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://cdn.jsdelivr.net/gh/zhangzhiwei0905/MyStaticFile@master/static_files/img/pexels-photo-3422964.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/04/14/java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-04-14T09:07:14.000Z" title="Created 2022-04-14 17:07:14">2022-04-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 张智为</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://zhangzhiwei0905.github.io/2022/04/14/java%E5%9F%BA%E7%A1%80/'
    this.page.identifier = '2022/04/14/java基础/'
    this.page.title = 'Java基础'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="7785460928" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="/true"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>